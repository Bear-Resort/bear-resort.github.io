---
title: "Brody Time Logger"
---

<style>
/* [Original style, unchanged for brevity, same as your code above] */
body {
  background: var(--background-color);
  margin: 0; padding: 0;
  min-height: 100vh;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
}
.container {
  background: var(--background-light);
  border-radius: 12px;
  box-shadow: 0 0 20px rgba(0,0,0,0.08);
  padding: 32px 24px 22px 24px;
  margin-top: 32px;
  text-align: center;
  display: flex; flex-direction: column; align-items: center;
}
h1 {
  margin-bottom: 24px;
  font-size: 2rem;
  font-weight: 600;
}
#checkin-btn {
  margin: 12px 0;
  font-size: 1.15rem;
  padding: 14px 32px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  transition: background 0.2s;
}
#checkin-btn:disabled {
  cursor: not-allowed;
}
#msg {
  margin: 10px 0 20px 0;
  color: #c65836;
  font-size: .98rem;
  min-height: 20px;
}
.streak-calendar-wrap {
  width: 100%;
  display: flex; flex-direction: column; align-items: center;
  margin-top: 12px;
}
.streak-calendar {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: flex-end;
  gap: 8px;
  width: 100%;
  min-height: 80px;
  margin-bottom: 10px;
}
/* ... retain all your original CSS for calendar/motivation ... */
</style>

<div class="container">
  <h1>Brody Stay Logger</h1>
  <button id="checkin-btn" disabled>Start</button>
  <div id="msg"></div>
  <div class="streak-calendar-wrap">
    <div class="streak-calendar" id="streak-calendar"></div>
  </div>
  <div class="motivation" id="motivation"></div>
</div>

<!-- Language switcher/other stuff if you have, not included for brevity -->

<script type="module">
// --- [ MOTIVATION LINES ] ---
const MOTIVATIONS = [
  "Consistency breeds success.",
  "Today in Brody counts!",
  "Small steps, big impact.",
  "Keep pushing forward!",
  "Momentum is everything.",
  "Attention is all you need.",
  "Stay strong, stay productive!",
  "Your future thanks you."
];
function getMotivation(idx = null) {
  if (idx == null) idx = new Date().getMinutes() % MOTIVATIONS.length;
  return MOTIVATIONS[idx];
}
// --- [ LOCATION & BRODY CONSTANTS ] ---
const BRODY_LAT = 39.32850;
const BRODY_LON = -76.61922;
const BRODY_RADIUS = 25; // meters

const STORAGE_PREFIX = 'brody_'; // to avoid collision with other keys
const CHECKIN_KEY = STORAGE_PREFIX + 'checkin_dates';
const SESSION_KEY = STORAGE_PREFIX + 'session'; // stores {startTime, validTime, dayKey}

// --- [ UTILS ] ---
function degreesToRadians(deg) { return deg * Math.PI / 180; }
function haversine(lat1, lon1, lat2, lon2) {
  // Returns distance in meters
  const R = 6371000; // m
  const dLat = degreesToRadians(lat2 - lat1);
  const dLon = degreesToRadians(lon2 - lon1);
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(degreesToRadians(lat1)) * Math.cos(degreesToRadians(lat2)) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}
// For consistency, use local time for dayKey
function getBrodyDayKey(date) {
  let d = new Date(date);
  let hr = d.getHours();
  // If current hour is 0 or 1 (midnight to 2am, exclusive) use yesterday
  if (hr < 2) d.setDate(d.getDate() - 1);
  return d.getFullYear() + "-" + String(d.getMonth()+1).padStart(2,'0') + "-" + String(d.getDate()).padStart(2,'0');
}
function getDisplayDate(date) {
  // Local time, formatted
  return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
}
function parseDateSafe(val) { return val ? new Date(val) : null; }

function prettyDuration(ms) {
  if (!ms || ms < 60000) return '0 min';
  let s = Math.floor(ms/1000);
  let h = Math.floor(s/3600); s = s%3600;
  let m = Math.floor(s/60);
  let str = `${m} min`;
  if (h) str = `${h} hr ` + str;
  return str;
}

// --- [ STREAK CALENDAR - you can extend/adapt this to show total time if desired] ---
function getPastBrodyDays(today = new Date()) {
  let days = [];
  for (let i=9; i>=0; i--) {
    let d = new Date(today);
    d.setDate(d.getDate() - i);
    days.push(getBrodyDayKey(d));
  }
  return days;
}
function getCheckedInDates() {
  let map = {};
  try {
    let raw = localStorage.getItem(CHECKIN_KEY);
    if (raw && typeof raw === "string") map = JSON.parse(raw);
  } catch (e) {}
  return map && typeof map === "object" ? map : {};
}
function addCheckedInDate(dayKey, ms, start, end) {
  // ms: milliseconds duration, start/end: timestamp string
  const checked = getCheckedInDates();
  checked[dayKey] = {
    minutes: Math.round((ms||1)/60000),
    start: start ? new Date(start).toISOString() : null,
    end: end ? new Date(end).toISOString() : null
  };
  localStorage.setItem(CHECKIN_KEY, JSON.stringify(checked));
}
function drawStreakCalendar() {
  const checkedIn = getCheckedInDates();
  const brodyDays = getPastBrodyDays();
  let div = document.getElementById('streak-calendar');
  div.innerHTML = '';
  // Month labels for each
  let monthLabels = Array(10).fill('');
  for(let i=0; i<10; ++i){
    const [y, m, d] = brodyDays[i].split('-').map(Number);
    const dd = new Date(y, m-1, d);
    if(i===0 || dd.getDate()===1) {
      monthLabels[i] = dd.toLocaleString(undefined, {month:'short'}).toUpperCase();
    }
  }
  const todayKey = getBrodyDayKey(new Date());
  for(let i=0; i<10; ++i){
    const dayKey = brodyDays[i];
    const [y,m,d] = dayKey.split('-').map(Number);
    const dd = new Date(y, m-1, d);
    const info = checkedIn[dayKey];
    const isToday = dayKey===todayKey;
    let stack = document.createElement('div');
    stack.className = 'streak-day-stack';
    let mLabel = document.createElement('div');
    mLabel.className = 'month-label';
    mLabel.innerHTML = monthLabels[i]? monthLabels[i] : "&nbsp;";
    stack.appendChild(mLabel);
    let cell = document.createElement('div');
    cell.className = 'streak-day' +
      (info ? ' checked' : '') + (isToday ? ' today' : '');

    let weekSpan = document.createElement('span');
    weekSpan.className = 'day-week';
    weekSpan.textContent = dd.toLocaleDateString(undefined, { weekday:'short' });
    let daySpan = document.createElement('span');
    daySpan.className = 'day-num';
    daySpan.textContent = dd.getDate();
    cell.appendChild(weekSpan);
    cell.appendChild(daySpan);
    // minutes
    if (info && info.minutes>0) {
      let minDiv = document.createElement('div');
      minDiv.style.fontSize = '0.98em';
      minDiv.style.marginTop = '2px';
      minDiv.textContent = `${info.minutes} min`;
      cell.appendChild(minDiv);
    }

    stack.appendChild(cell);
    div.appendChild(stack);
  }
}

// --- [ TIME WINDOW CONTROL ] ---
function isOperatingNow(date=new Date()){
  let hr = date.getHours(), min = date.getMinutes();
  let t = hr * 60 + min;
  return !(t >= 120 && t < 450); // 2:00am to 7:30am
}
// --- [ MAIN LOGIC ] ---
let userLocation = undefined, locationErr = false, userInRange = false;
let locationTimer = null;
let periodicTimer = null;
let session = null; // {startTime, validTime, dayKey}

// To handle localstorage get/set for session, so everything is robust
function getSession() {
  try {
    const raw = localStorage.getItem(SESSION_KEY);
    if (!raw) return null;
    const s = JSON.parse(raw);
    if (!s || !s.startTime || !s.validTime || !s.dayKey) return null;
    return {
      startTime: s.startTime,
      validTime: s.validTime,
      dayKey: s.dayKey
    }
  } catch(e) { return null; }
}
function setSession(obj) {
  localStorage.setItem(SESSION_KEY, JSON.stringify(obj));
}
function clearSession() {
  localStorage.removeItem(SESSION_KEY);
}

// Location check and update logic
function updateLocationState(position) {
  const lat = position.coords.latitude, lon = position.coords.longitude;
  userLocation = {lat, lon};
  const dist = haversine(lat, lon, BRODY_LAT, BRODY_LON);
  userInRange = dist <= BRODY_RADIUS;
  locationErr = false;
  updateUI();
}
function locationError(err) {
  locationErr = true;
  userLocation = undefined;
  userInRange = false;
  updateUI();
}
function obtainLocation() {
  if (!navigator.geolocation) {
    locationErr = true; updateUI();
    return;
  }
  navigator.geolocation.getCurrentPosition(
    updateLocationState,
    locationError,
    {enableHighAccuracy:true, timeout:10000, maximumAge:60000}
  );
}

// --- [ SESSION LOGGING ] ---
// Periodically called (every 15min or on events), as long as session is open
function periodicSessionTick(force_now=false) {
  const now = new Date();
  if (!isOperatingNow(now)) {
    // Off hours, terminate session now!
    if (session) terminateSession(false, "Brody is closed, session auto-terminated.");
    return;
  }
  // Location check (async, but we can use last known in userLocation)
  if (!userLocation || !userInRange) {
    // Out of location, terminate session (don't update validTime)
    if (session) terminateSession(false, "Moved out of Brody, session terminated.");
    return;
  }
  // Update validTime if still in range
  if (session) {
    let newValid = now.getTime(); // in milliseconds
    session.validTime = newValid;
    setSession(session);
    // (No notification popup until user leaves, unless forced: see terminateSession)
  }
}
// --- [ SESSION HANDLERS ] ---
function startSession() {
  const now = new Date();
  const startMs = now.getTime();
  const dayKey = getBrodyDayKey(now);
  session = {
    startTime: startMs,
    validTime: startMs,
    dayKey: dayKey
  };
  setSession(session);
  updateUI();
  // Set periodic timer (every 15min), also check on browser resume/refresh/etc
  if (periodicTimer) clearInterval(periodicTimer);
  periodicTimer = setInterval(periodicSessionTick, 15*60*1000); // 15min
}
function terminateSession(userAction=true, popupMsg) {
  if (!session) return;
  const now = new Date();
  // If in Brody, update validTime to now (for user-initiated leave)
  let validTime = session.validTime;
  let leaveTime = now.getTime();
  if (userAction && userInRange) {
    validTime = leaveTime;
  }
  // Compute time stayed
  const startTime = session.startTime;
  let timeStayedMs = Math.max(validTime - startTime, 0);
  // Only log if spent at least 1 min inside
  if (timeStayedMs >= 60000) {
    // Save checkin info for dayKey
    addCheckedInDate(session.dayKey, timeStayedMs, new Date(startTime), new Date(validTime));
  }
  drawStreakCalendar();
  // Popup dialog/alert
  let msg = "";
  if (timeStayedMs < 60000) {
    msg = "You spent less than 1 min in Brody.";
  } else {
    msg = `You stayed in Brody for: ${prettyDuration(timeStayedMs)}\nStart: ${getDisplayDate(new Date(startTime))}\nEnd: ${getDisplayDate(new Date(validTime))}`;
  }
  if (popupMsg) {
    msg = popupMsg + "\n\n" + msg;
  }
  alert(msg);

  clearSession();
  session = null;
  if (periodicTimer) clearInterval(periodicTimer);
  periodicTimer = null;
  updateUI();
}

function alreadyHaveSession() {
  return !!getSession();
}
// --- [ UI ] ---
function updateUI() {
  const btn = document.getElementById('checkin-btn');
  const msg = document.getElementById('msg');

  const now = new Date();
  if (!isOperatingNow(now)) {
    // Not during Brody open hours: kill session if ongoing
    btn.disabled = true;
    btn.textContent = 'Start';
    msg.textContent = "Brody is not open between 2:00-7:30AM.";
    if(session) terminateSession(false,"Brody is closed, session auto-terminated.");
    return;
  }
  if (locationErr) {
    btn.disabled = true;
    btn.textContent = 'Start';
    msg.textContent = "Location permission denied or unavailable.";
    return;
  }
  if (typeof userLocation === 'undefined') {
    btn.disabled = true;
    btn.textContent = 'Start';
    msg.textContent = "Waiting for location...";
    return;
  }
  if (!userInRange) {
    btn.disabled = true;
    btn.textContent = session ? "Leave" : "Start";
    msg.textContent = "You are not within Brody range.";
    return;
  }

  // Are we IN a session?
  session = getSession();
  if (session) {
    btn.disabled = false;
    btn.textContent = "Leave";
    msg.textContent = "Click leave when you're done!";
  } else {
    // If already checked in today, prevent duplicate session
    const todayKey = getBrodyDayKey(now);
    const checkedIn = getCheckedInDates();
    if (checkedIn && checkedIn[todayKey]) {
      btn.textContent = "Start";
      btn.disabled = true;
      msg.textContent = "You have already logged a session today.";
      return;
    }
    btn.textContent = "Start";
    btn.disabled = false;
    msg.textContent = "Ready to start session at Brody!";
  }
}

// --- [ APP INIT ] ---
function init() {
  // initial calendar and motivation
  drawStreakCalendar();
  document.getElementById('motivation').textContent = getMotivation();

  if (locationTimer) clearInterval(locationTimer);
  // Try get location on load, and every 3min for UI
  obtainLocation();
  locationTimer = setInterval(obtainLocation, 180*1000);

  // On resume (every 1min), check session
  setInterval(() => {
    obtainLocation(); // trigger periodic location update as well
    if (session) periodicSessionTick();
    updateUI();
  }, 60000);

  // On start/leave btn
  document.getElementById('checkin-btn').addEventListener('click', () => {
    session = getSession();
    if (!session) {
      startSession();
    } else {
      terminateSession(true);
    }
  });

  updateUI();

  // On page visibility/resume, extra check, for resilience
  document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
      obtainLocation();
      if (session) periodicSessionTick(true); // forcibly check on resume
      updateUI();
    }
  });
}
init();
</script>